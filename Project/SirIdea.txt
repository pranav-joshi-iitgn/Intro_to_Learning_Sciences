My primary motivation is to convey the beauty of the subject, get students interested, and then getting them to work on a large-ish codebase. This would be common to many of the systems courses if I teach them: compilers, os, networks... Problems that pop-up when developing in the large (with multiple people, spanning non-trivial time period) can only be really understood while writing large programs yourself. I think in Computing, DSAx, ... there are no opportunities to do this. Main technical objectives are teaching lexing + parsing (a task that pops up almost everywhere in programming) and to expose students to the some aspects of engineering with language design as a medium (types, mutability, first-class vs second-class). I think understanding these issues are important to really understand correctness and efficiency barriers and can form a technical basis for many choices. For example, a language with first-class functions lose a lot of optimization opportunities but gain a lot of abstraction opportunities leading to better correctness. Such tradeoffs are common in engineering. And, compilers sort of give a well-understood case of tradeoffs.